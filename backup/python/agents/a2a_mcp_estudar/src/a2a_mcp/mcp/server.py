# type: ignore
import json
import os
import datetime
import hashlib

from pathlib import Path

import google.generativeai as genai
import numpy as np
import pandas as pd

from a2a_mcp.common.utils import init_api_key
from mcp.server.fastmcp import FastMCP
from mcp.server.fastmcp.utilities.logging import get_logger
from .diego_tools_bridge import diego_tools_bridge, call_diego_tool, is_diego_tools_available, get_diego_tools_info


logger = get_logger(__name__)
AGENT_CARDS_DIR = 'agent_cards'
MODEL = 'models/embedding-001'

# Removidas as constantes relacionadas a Places API e SQLite
# SQLLITE_DB = 'travel_agency.db'
# PLACES_API_URL = 'https://places.googleapis.com/v1/places:searchText'


def generate_embeddings(text):
    """Generates embeddings for the given text using Google Generative AI.

    Args:
        text: The input string for which to generate embeddings.

    Returns:
        A list of embeddings representing the input text.
    """
    return genai.embed_content(
        model=MODEL,
        content=text,
        task_type='retrieval_document',
    )['embedding']


def load_agent_cards():
    """Loads agent card data from JSON files within a specified directory.

    Returns:
        A list containing JSON data from an agent card file found in the specified directory.
        Returns an empty list if the directory is empty, contains no '.json' files,
        or if all '.json' files encounter errors during processing.
    """
    card_uris = []
    agent_cards = []
    dir_path = Path(AGENT_CARDS_DIR)
    if not dir_path.is_dir():
        logger.error(
            f'Agent cards directory not found or is not a directory: {AGENT_CARDS_DIR}'
        )
        return agent_cards

    logger.info(f'Loading agent cards from card repo: {AGENT_CARDS_DIR}')

    for filename in os.listdir(AGENT_CARDS_DIR):
        if filename.lower().endswith('.json'):
            file_path = dir_path / filename

            if file_path.is_file():
                logger.info(f'Reading file: {filename}')
                try:
                    with file_path.open('r', encoding='utf-8') as f:
                        data = json.load(f)
                        card_uris.append(
                            f'resource://agent_cards/{Path(filename).stem}'
                        )
                        agent_cards.append(data)
                except json.JSONDecodeError as jde:
                    logger.error(f'JSON Decoder Error {jde}')
                except OSError as e:
                    logger.error(f'Error reading file {filename}: {e}.')
                except Exception as e:
                    logger.error(
                        f'An unexpected error occurred processing {filename}: {e}',
                        exc_info=True,
                    )
    logger.info(
        f'Finished loading agent cards. Found {len(agent_cards)} cards.'
    )
    return card_uris, agent_cards


def build_agent_card_embeddings() -> pd.DataFrame:
    """Loads agent cards, generates embeddings for them, and returns a DataFrame.

    Returns:
        Optional[pd.DataFrame]: A Pandas DataFrame containing the original
        'agent_card' data and their corresponding 'Embeddings'. Returns None
        if no agent cards were loaded initially or if an exception occurred
        during the embedding generation process.
    """
    card_uris, agent_cards = load_agent_cards()
    logger.info('Generating Embeddings for agent cards')
    try:
        if agent_cards:
            df = pd.DataFrame(
                {'card_uri': card_uris, 'agent_card': agent_cards}
            )
            df['card_embeddings'] = df.apply(
                lambda row: generate_embeddings(json.dumps(row['agent_card'])),
                axis=1,
            )
            return df
        logger.info('Done generating embeddings for agent cards')
    except Exception as e:
        logger.error(f'An unexpected error occurred : {e}.', exc_info=True)
        return None


def serve(host, port, transport):  # noqa: PLR0915
    """Initializes and runs the Agent Cards MCP server.

    Args:
        host: The hostname or IP address to bind the server to.
        port: The port number to bind the server to.
        transport: The transport mechanism for the MCP server (e.g., 'stdio', 'sse').

    Raises:
        ValueError: If the 'GOOGLE_API_KEY' environment variable is not set.
    """
    init_api_key()
    logger.info('Starting Agent Cards MCP Server')
    mcp = FastMCP('agent-cards', host=host, port=port)

    df = build_agent_card_embeddings()

    @mcp.tool(
        name='find_agent',
        description='Finds the most relevant agent card based on a natural language query string.',
    )
    def find_agent(query: str) -> str:
        """Finds the most relevant agent card based on a query string.

        This function takes a user query, typically a natural language question or a task generated by an agent,
        generates its embedding, and compares it against the
        pre-computed embeddings of the loaded agent cards. It uses the dot
        product to measure similarity and identifies the agent card with the
        highest similarity score.

        Args:
            query: The natural language query string used to search for a
                   relevant agent.

        Returns:
            The json representing the agent card deemed most relevant
            to the input query based on embedding similarity.
        """
        query_embedding = genai.embed_content(
            model=MODEL, content=query, task_type='retrieval_query'
        )
        dot_products = np.dot(
            np.stack(df['card_embeddings']), query_embedding['embedding']
        )
        best_match_index = np.argmax(dot_products)
        logger.debug(
            f'Found best match at index {best_match_index} with score {dot_products[best_match_index]}'
        )
        return df.iloc[best_match_index]['agent_card']

    # 🛠️ FERRAMENTAS MCP EXEMPLO - Focando nas ferramentas úteis
    @mcp.tool(name='generate_unique_id')
    def generate_unique_id(prefix: str = "task") -> dict:
        """Gera um ID único para tarefas, sessões ou outros objetos"""
        logger.info(f'Generating unique ID with prefix: {prefix}')
        
        timestamp = datetime.datetime.now().isoformat()
        unique_string = f"{prefix}_{timestamp}"
        unique_id = hashlib.sha256(unique_string.encode()).hexdigest()[:16]
        
        return {
            'id': f"{prefix}_{unique_id}",
            'timestamp': timestamp,
            'prefix': prefix,
            'full_hash': unique_id
        }

    @mcp.tool(name='system_info')
    def system_info() -> dict:
        """
        Retorna informações sobre o sistema A2A MCP e FERRAMENTAS disponíveis.
        
        IMPORTANTE: Este comando lista FERRAMENTAS MCP, não agentes delegáveis.
        Para listar agentes disponíveis para delegação, use 'list_agents'.
        
        Retorna: Todas as capacidades/ferramentas do sistema MCP (17 total)
        """
        logger.info('Retrieving system information')
        
        return {
            'system_name': 'A2A MCP System',
            'version': '1.0.0',
            'mcp_server': {
                'host': host,
                'port': port,
                'transport': transport,
                'url': f'http://{host}:{port}/sse'
            },
            'available_tools': [
                'find_agent',
                'generate_unique_id',
                'system_info',
                'validate_json',
                'format_text',
                'calculate_basic',
                # DiegoTools
                'web_navigate',
                'web_screenshot',
                'web_click',
                'web_type',
                'web_get_content',
                'open_browser',
                'browser_open',
                'list_agents',
                'get_agent_details',
                'analyze_agent',
                'search_agents'
            ],
            'diego_tools': get_diego_tools_info(),
            'agent_cards_count': len(df) if df is not None else 0,
            'timestamp': datetime.datetime.now().isoformat()
        }

    @mcp.tool(name='validate_json')
    def validate_json(json_string: str) -> dict:
        """Valida se uma string é JSON válido"""
        logger.info('Validating JSON string')
        
        try:
            parsed = json.loads(json_string)
            return {
                'valid': True,
                'parsed': parsed,
                'type': type(parsed).__name__,
                'size': len(json_string),
                'error': None
            }
        except json.JSONDecodeError as e:
            return {
                'valid': False,
                'parsed': None,
                'type': None,
                'size': len(json_string),
                'error': str(e)
            }

    @mcp.tool(name='format_text')
    def format_text(text: str, format_type: str = "upper") -> dict:
        """Formata texto de diferentes maneiras"""
        logger.info(f'Formatting text with type: {format_type}')
        
        formats = {
            'upper': text.upper(),
            'lower': text.lower(),
            'title': text.title(),
            'capitalize': text.capitalize(),
            'strip': text.strip(),
            'reverse': text[::-1],
            'length': len(text)
        }
        
        if format_type == 'all':
            return {
                'original': text,
                'formatted': formats,
                'applied_format': 'all'
            }
        elif format_type in formats:
            return {
                'original': text,
                'formatted': formats[format_type],
                'applied_format': format_type
            }
        else:
            return {
                'original': text,
                'formatted': text,
                'applied_format': 'none',
                'error': f'Unknown format type: {format_type}',
                'available_formats': list(formats.keys()) + ['all']
            }

    @mcp.tool(name='calculate_basic')
    def calculate_basic(operation: str, a: float, b: float = 0) -> dict:
        """Realiza cálculos básicos"""
        logger.info(f'Performing calculation: {operation}({a}, {b})')
        
        try:
            operations = {
                'add': a + b,
                'subtract': a - b,
                'multiply': a * b,
                'divide': a / b if b != 0 else None,
                'power': a ** b,
                'modulo': a % b if b != 0 else None,
                'square': a ** 2,
                'sqrt': a ** 0.5 if a >= 0 else None,
                'abs': abs(a),
                'round': round(a, int(b)) if operation == 'round' else round(a)
            }
            
            if operation in operations:
                result = operations[operation]
                if result is None:
                    return {
                        'operation': operation,
                        'operands': [a, b] if operation not in ['square', 'sqrt', 'abs', 'round'] else [a],
                        'result': None,
                        'error': 'Division by zero or invalid operation'
                    }
                
                return {
                    'operation': operation,
                    'operands': [a, b] if operation not in ['square', 'sqrt', 'abs', 'round'] else [a],
                    'result': result,
                    'error': None
                }
            else:
                return {
                    'operation': operation,
                    'operands': [a, b],
                    'result': None,
                    'error': f'Unknown operation: {operation}',
                    'available_operations': list(operations.keys())
                }
        except Exception as e:
            return {
                'operation': operation,
                'operands': [a, b],
                'result': None,
                'error': str(e)
            }

    # 🌐 DIEGOTOOLS INTEGRATION - Ferramentas do mcp-run-ts-tools
    @mcp.tool(name='web_navigate')
    async def web_navigate(url: str, wait_for: str = None) -> dict:
        """Navegar para uma URL usando Puppeteer"""
        logger.info(f'Navigating to URL: {url}')
        params = {'url': url}
        if wait_for:
            params['wait_for'] = wait_for
        return await call_diego_tool('web_navigate', **params)

    @mcp.tool(name='web_screenshot')
    async def web_screenshot(name: str, selector: str = None) -> dict:
        """Tirar screenshot da página atual"""
        logger.info(f'Taking screenshot: {name}')
        params = {'name': name}
        if selector:
            params['selector'] = selector
        return await call_diego_tool('web_screenshot', **params)

    @mcp.tool(name='web_click')
    async def web_click(selector: str) -> dict:
        """Clicar em um elemento da página"""
        logger.info(f'Clicking element: {selector}')
        return await call_diego_tool('web_click', selector=selector)

    @mcp.tool(name='web_type')
    async def web_type(selector: str, text: str) -> dict:
        """Digitar texto em um campo"""
        logger.info(f'Typing in element: {selector}')
        return await call_diego_tool('web_type', selector=selector, text=text)

    @mcp.tool(name='web_get_content')
    async def web_get_content(selector: str = None) -> dict:
        """Obter conteúdo da página"""
        logger.info('Getting page content')
        params = {}
        if selector:
            params['selector'] = selector
        return await call_diego_tool('web_get_content', **params)

    @mcp.tool(name='open_browser')
    async def open_browser(headless: bool = True) -> dict:
        """Abrir browser Puppeteer"""
        logger.info(f'Opening browser (headless={headless})')
        return await call_diego_tool('open_browser', headless=headless)

    @mcp.tool(name='browser_open')
    async def browser_open(url: str) -> dict:
        """Abrir URL no browser padrão"""
        logger.info(f'Opening URL in default browser: {url}')
        return await call_diego_tool('browser_open', url=url)

    @mcp.tool(name='list_agents')
    async def list_agents() -> dict:
        """
        Lista AGENTES disponíveis para delegação de tarefas.
        
        IMPORTANTE: Este comando lista AGENTES específicos que podem ser usados,
        não as ferramentas MCP. Para ver ferramentas use 'system_info'.
        
        Retorna: Agentes individuais disponíveis no Claude Flow para coordenação
        """
        logger.info('Listing available agents')
        return await call_diego_tool('list_agents')

    @mcp.tool(name='get_agent_details')
    async def get_agent_details(agent_id: str) -> dict:
        """Obter detalhes de um agente específico"""
        logger.info(f'Getting agent details: {agent_id}')
        return await call_diego_tool('get_agent_details', agent_id=agent_id)

    @mcp.tool(name='analyze_agent')
    async def analyze_agent(agent_id: str) -> dict:
        """Analisar capacidades de um agente"""
        logger.info(f'Analyzing agent: {agent_id}')
        return await call_diego_tool('analyze_agent', agent_id=agent_id)

    @mcp.tool(name='search_agents')
    async def search_agents(query: str) -> dict:
        """Buscar agentes por critérios"""
        logger.info(f'Searching agents: {query}')
        return await call_diego_tool('search_agents', query=query)

    @mcp.resource('resource://agent_cards/list', mime_type='application/json')
    def get_agent_cards() -> dict:
        """Retrieves all loaded agent cards as a json / dictionary for the MCP resource endpoint.

        This function serves as the handler for the MCP resource identified by
        the URI 'resource://agent_cards/list'.

        Returns:
            A json / dictionary structured as {'agent_cards': [...]}, where the value is a
            list containing all the loaded agent card dictionaries. Returns
            {'agent_cards': []} if the data cannot be retrieved.
        """
        resources = {}
        logger.info('Starting read resources')
        resources['agent_cards'] = df['card_uri'].to_list()
        return resources

    @mcp.resource(
        'resource://agent_cards/{card_name}', mime_type='application/json'
    )
    def get_agent_card(card_name: str) -> dict:
        """Retrieves an agent card as a json / dictionary for the MCP resource endpoint.

        This function serves as the handler for the MCP resource identified by
        the URI 'resource://agent_cards/{card_name}'.

        Returns:
            A json / dictionary
        """
        resources = {}
        logger.info(
            f'Starting read resource resource://agent_cards/{card_name}'
        )
        resources['agent_card'] = (
            df.loc[
                df['card_uri'] == f'resource://agent_cards/{card_name}',
                'agent_card',
            ]
        ).to_list()

        return resources

    logger.info(
        f'Agent cards MCP Server at {host}:{port} and transport {transport}'
    )
    mcp.run(transport=transport)
